"""
Author: Egheosa Ogbomo
Date: 11/10/2023

An implementation of a genetic algoritm that:

- Allows user to generate varying lengths of molecules for optimisation
- Define their own fitness function (an ML algorithm or MD simulation framework)
- Remove molecules with undesired substructures from populations
- Define likelihood of different mutations/crossovers occuring
- Store SMILES strings and evaluations of valid(?) molecules from each generation in csv
- Allow users to define which elements and mutations are allowed from a database (which can be in csv form)
- Remove disconnected fragments
- Check for molecular similarity
- Illustrate mutated molecules between generations
- Plot an illustration of generated molecules as a word embedding
- Find most common substructure present within a generation of champion molecules to advise future generations
- Limit number of atoms generated by algorithm
- Generate options that conform to a specific type of base oils (e.g. PAO/silicone oils)
- Impose maximum number of heavy atoms
- Recreate and visualise certain mutations
- Assign molecule ID to track mutation history through generation

Possible Mutations
- Add Atom
- Replace Atom
- Change Bond Order
- Add Fragment 
- Delete atom
- Replace Fragment

CONSIDERATIONS

- How to initialise and change population of fragments for remove fragments module

- Can we keep track of modifications, and track how each legal modification to impacts (i.e. increases or decreases)
visosity/conductivity to determine which modifications are best

- Best way to initialise population

- How to penalise long surviving molecules to encourage even greater diversity in later generations

- Need to decide best fingerprint for calculating molecular similarity

- Varying (decreasing) elitism factor to further increase novelty of molecules
"""

############### ENVIRONMENT SETUP ############
import subprocess
def runcmd(cmd, verbose = False, *args, **kwargs):
    #bascially allows python to run a bash command, and the code makes sure 
    #the error of the subproceess is communicated if it fails
    process = subprocess.run(
        cmd,
        text=True,
        shell=True)
    
    return process

################# IMPORTS ###################
import Genetic_Algorithm_Functions as GAF
from rdkit import Chem
from rdkit.Chem import Draw
from random import sample
from rdkit.Chem import AllChem
from rdkit.Chem.Draw import MolDrawing, DrawingOptions
from random import choice as rnd
from os.path import join
from time import sleep
import sys
from rdkit.Chem.Draw import rdMolDraw2D
from MoleculeDifferenceViewer import view_difference
from copy import deepcopy
from operator import itemgetter
import os
import pandas as pd
import random
import numpy as np
# from gt4sd.properties import PropertyPredictorRegistry


DrawingOptions.includeAtomNumbers=True
DrawingOptions.bondLineWidth=1.8
DrawingOptions.atomLabelFontSize=14

### Fragments
Mols = ['CCCCCCCCCCCCCCCC(CC1CCCCC1)CC2CCCCC2', 'CCCCCCCCCCCCC(CCCCCCCCCCCC)C1CCCCC1',
    'CCCCCCCCCCCCCCCC', 'CCCCC(CC)COC(=O)CCCCCCCCC(=O)OCC(CC)CCCC', 
             'CCCCCCCCCCCCC(c1ccccc1)CCCCCCCCCCCC', 'CC(C)CCCC(C)CCCC(C)CCCCC(C)CCCC(C)CCCC(C)C', 'CC1=CC=CC2=CC=CC=C12',
             'CCCCCCCCCCC(CCCCCCCCCC)CCCCCCCCCC', 'C(c1ccccc1)CCCCCC(c1ccccc1)CCCCCCC']

fragments = ['CCCC', 'CCCCC', 'C(CC)CCC', 'CCC(CCC)CC', 'CCCC(C)CC', 'CCCCCCCCC', 'CCCCCCCC', 'CCCCCC', 'C(CCCCC)C', 'C1CCCCC1', 'C1CCCC1', 'c1ccccc1']

MoleculeDatabase = pd.read_csv('MoleculeDatabase.csv')

Mols = [Chem.MolFromSmiles(x) for x in Mols]
fragments = [Chem.MolFromSmiles(x) for x in fragments]

### ATOM NUMBERS
Atoms = ['C', 'O']
AtomMolObjects = [Chem.MolFromSmiles(x) for x in Atoms]
AtomicNumbers = []

# Getting Atomic Numbers for Addable Atoms
for Object in AtomMolObjects:
     for atom in Object.GetAtoms():
          AtomicNumbers.append(atom.GetAtomicNum())         

### BOND TYPES
BondTypes = [Chem.BondType.SINGLE, Chem.BondType.DOUBLE]

###### Implementing Genetic Algorithm Using Functions Above

Mutations = ['AddAtom', 'ReplaceAtom', 'ReplaceBond', 'RemoveAtom', 'AddFragment', 'InsertAromatic', 'RemoveFragment']

# GENETIC ALGORITHM HYPERPARAMETERS
Silent = True # Edit outputs to only print if this flag is False
NumElite = 25
IDcounter = 0
FirstGenerationAttempts = 0
MasterMoleculeList = [] #Keeping track of all generated molecules
FirstGenSimList = []
MaxNumHeavyAtoms = 50
MinNumHeavyAtoms = 5
MutationRate = 0.4
showdiff = False # Whether or not to display illustration of each mutation
GenerationSize = 50
LOPLS = False # Whether or not to use OPLS or LOPLS, False uses OPLS
MaxGenerations = 3
MaxMutationAttempts = 200
Fails = 0
NumRuns = 10
NumAtoms = 12000
Agent = 'Agent1'

PYTHONPATH = 'C:/Users/eeo21/AppData/Local/Programs/Python/Python310/python.exe'
STARTINGDIR = deepcopy(os.getcwd())
# PYTHONPATH = 'python3'
GAF.runcmd(f'mkdir Molecules')
os.chdir(join(os.getcwd(), 'Molecules'))
GAF.runcmd(f'mkdir Generation_1')
os.chdir(STARTINGDIR)

# Master Dataframe where molecules from all generations will be stored
MoleculeDatabase = pd.DataFrame(columns=['SMILES', 'MolObject', 'MutationList', 'HeavyAtoms', 'ID', 'Charge', 'MolMass', 'Predecessor', 'Score', 'Density100C', 'DViscosity40C',
                                        'DViscosity100C', 'KViscosity40C', 'KViscosity100C', 'KVI', 'DVI', 'ThermalConductivity', 'Toxicity', 'SCScore', 'Density40C', 'SimilarityScore'])

# Generation Dataframe to store molecules from each generation
GenerationDatabase = pd.DataFrame(columns=['SMILES', 'MolObject', 'MutationList', 'HeavyAtoms', 'ID', 'Charge', 'MolMass', 'Predecessor', 'Score', 'Density100C', 'DViscosity40C',
                                        'DViscosity100C', 'KViscosity40C', 'KViscosity100C', 'KVI', 'DVI', 'ThermalConductivity', 'Toxicity', 'SCScore', 'Density40C', 'SimilarityScore'])

# Initialise population 
while len(MoleculeDatabase) < GenerationSize:
    # Return to starting directory
    os.chdir(STARTINGDIR)

    print('\n###########################################################')
    print(f'Attempt number: {FirstGenerationAttempts}')
    StartingMolecule = rnd(Mols) #Select starting molecule

    Mutation = rnd(Mutations)
    AromaticMolecule = fragments[-1]

    # Perform mutation 
    result = GAF.Mutate(StartingMolecule, Mutation, AromaticMolecule, AtomicNumbers, BondTypes, Atoms, showdiff, Fragments=fragments)

    # Implement checks based on predetermined criteria (MolLength, Illegal Substructs etc.)
    if GAF.GenMolChecks(result, MasterMoleculeList, MaxNumHeavyAtoms, MinNumHeavyAtoms, MaxAromRings=2) == None:
        MutMol = None
    else:
        HeavyAtoms = result[0].GetNumHeavyAtoms() # Get number of heavy atoms in molecule
        MutMol = result[0] # Get Mol object of mutated molecule
        MolMass = GAF.GetMolMass(MutMol) # Get estimate of of molecular mass 
        MutMolSMILES = result[2] # SMILES of mutated molecule
        Predecessor = [None, None, Mutation] # Get history of last two mutations performed on candidate
        ID = IDcounter

        # Try Making all the files 
        try:
            Name = f'Generation_1_Molecule_{ID}' # Set name of Molecule as its SMILES string

            # Set feature definition file path to OPLS or LOPLS depending on user choice 
            if LOPLS:
                LTCOMMAND = f"{join(os.getcwd(), 'rdlt.py')} --smi {MutMolSMILES} -n {Name} -l -c"
            else:
                LTCOMMAND = f"{join(os.getcwd(), 'rdlt.py')} --smi {MutMolSMILES} -n {Name} -c"
            
            #Attempt to parameterise with OPLS
            GAF.runcmd(f'{PYTHONPATH} {LTCOMMAND} > {STARTINGDIR}/{Name}.lt')

            #Get molecule charge
            charge = GAF.GetMolCharge(f'{os.getcwd()}/{Name}.lt')

            #If successful, generate a PDB of molecule to use with Packmol
            GAF.GeneratePDB(MutMolSMILES, PATH=join(STARTINGDIR, f'{Name}.pdb'))

            # Go into directory for this generation
            os.chdir(join(STARTINGDIR, 'Molecules', 'Generation_1'))
            
            # Make a directory for the current molecule if it can be parameterised 
            GAF.runcmd(f'mkdir {Name}')

            # Enter molecule specific directory
            os.chdir(join(os.getcwd(), f'{Name}'))

            #Check if file has already been made, skip if so, being sure not to make duplicate, otherwise move file to correct directory
            CWD = os.getcwd() #Need to declare otherwise will get CWD from location function is being called from
            GAF.CheckMoveFile(Name, STARTINGDIR, 'lt', CWD)
            GAF.CheckMoveFile(Name, STARTINGDIR, 'pdb', CWD)

            #Get estimate for Number of molecules 
            HMutMol = Chem.AddHs(MutMol)
            NumMols = int(NumAtoms/HMutMol.GetNumAtoms()) # Maybe add field seeing how many mols were added to box

            # Estimate starting box length
            BoxL = GAF.CalcBoxLen(MolMass=MolMass, TargetDens=0.8, NumMols=NumMols)

            # Make packmol files
            GAF.MakePackmolFile(Name, CWD, NumMols=NumMols, BoxL=BoxL)

            # Make Moltemplate files
            GAF.MakeMoltemplateFile(Name, CWD, NumMols=NumMols, BoxL=BoxL)

            # Make LAMMPS files
            GAF.MakeLAMMPSFile(Name, CWD, Temp=313, GKRuntime=1500000)
            GAF.MakeLAMMPSFile(Name, CWD, Temp=373, GKRuntime=1500000)

            if PYTHONPATH == 'python3':
                GAF.runcmd(f'packmol < {Name}.inp')
                GAF.runcmd(f'moltemplate.sh -pdb {Name}_PackmolFile.pdb {Name}_system.lt')

                # Check that Moltemplate has generated all necessary files 
                assert os.path.exists(join(CWD, f'{Name}_system.in.settings')), 'Settings file not generated'                 
                assert os.path.exists(join(CWD, f'{Name}_system.in.charges')), 'Charges file not generated'
                assert os.path.exists(join(CWD, f'{Name}_system.data')), 'Data file not generated'                    
                assert os.path.exists(join(CWD, f'{Name}_system.in.init')), 'Init file not generated'                

            # Update Molecule database
            MoleculeDatabase = GAF.DataUpdate(MoleculeDatabase, IDCounter=IDcounter, MutMolSMILES=MutMolSMILES, MutMol=MutMol, HeavyAtoms=HeavyAtoms,
                                              MutationList=[None, None, Mutation], ID=Name, Charge=charge, MolMass=MolMass, Predecessor=Predecessor)

            GenerationDatabase = GAF.DataUpdate(GenerationDatabase, IDCounter=IDcounter, MutMolSMILES=MutMolSMILES, MutMol=MutMol, HeavyAtoms=HeavyAtoms,
                                              MutationList=[None, None, Mutation], ID=Name, Charge=charge, MolMass=MolMass, Predecessor=Predecessor)
           
            # Generate list of molecules to simulate in this generation
            FirstGenSimList.append([Name, MutMolSMILES])
            MasterMoleculeList.append(MutMolSMILES) #Keep track of already generated molecules
            print(f'Final Molecule SMILES: {MutMolSMILES}') 
            IDcounter +=1
        
        except Exception as E:
            continue     
    FirstGenerationAttempts += 1

# Run MD simulations and retreive performance 
Generation = 1
CWD = join(STARTINGDIR, 'Molecules', f'Generation_{Generation}')
# Create and run array job for 40C viscosity
GAF.CreateArrayJob(STARTINGDIR, CWD, NumRuns, Generation=1, SimName='313K.lammps', Agent=Agent)

# Create and run array job for 100C viscosity
GAF.CreateArrayJob(STARTINGDIR, CWD, NumRuns, Generation=1, SimName='373K.lammps', Agent=Agent)

if PYTHONPATH == 'python3':
    GAF.runcmd(f'qsub {join(CWD, f"{Agent}_313K.lammps.pbs")}')
    GAF.runcmd(f'qsub {join(CWD, f"{Agent}_373K.lammps.pbs")}')

os.chdir(STARTINGDIR)

# Wait until array jobs have finished
MoveOn = False
while MoveOn == False:
    runcmd(f'qstat > sims.txt')
    sims = []
    try:
        with open(join(STARTINGDIR, 'sims.txt'), 'r') as file:
            next(file) #Avoiding the first two lines
            next(file)
            filelist = file.readlines()
            for sim in filelist:
                if Agent in sim:
                    sims.append(sim)
                    print(sim)
    except:
        pass

    # Check if array jobs have finished
    if len(sims) != 0:
        print('Waiting for 10 mins')
        sleep(600)
    else:
        MoveOn = True

MOLSMILESList = [x[-1] for x in FirstGenSimList]

# Here is where we will get the various values generated from the MD simulations
for Molecule, MOLSMILES in FirstGenSimList:
    try:
        # Create a function to wait until all simulations from this generation are finished
        os.chdir(join(STARTINGDIR, 'Molecules', 'Generation_1', Molecule))
        CWD = os.getcwd()

        ### Similarity Scores
        Scores = GAF.TanimotoSimilarity(MOLSMILES, MOLSMILESList)
        AvScore = 1 - (sum(Scores) / 50) # The higher the score, the less similar the molecule is to others

        ### SCScore
        SCScore = GAF.SCScore(MOLSMILES)
        SCScoreNorm = SCScore/5

        ### Toxicity
        ToxNorm = random.uniform(0, 1)
        # ToxNorm = GAF.Toxicity(MOLSMILES)

        ### Viscosity
        # DVisc40 = GAF.GetVisc(STARTDIR, Molecule, 313)
        # DVisc100 = GAF.GetVisc(STARTDIR, Molecule, 373)
        # Dens40 = GAF.GetDens(DensityFile)
        # Dens100 = GAF.GetDens(DensityFile
        DVisc40 = random.uniform(2, 30)
        DVisc100 = random.uniform(2, 8)

        ### Viscosity Index
        # Dens40 = GAF.GetDens(DensityFile)
        # Dens100 = GAF.GetDens(DensityFile)
        # KVI = GAF.GetKVI(DVisc40, DVisc100, Dens40, Dens100, STARTINGDIR)
        DVI = GAF.GetDVI(DVisc40, DVisc100)

        ### Thermal Conductivity
        ThermalK = random.uniform(1, 3)

        #Update Molecule Database
        IDNumber = int(Molecule.split('_')[-1])
        # MoleculeDatabase.at[IDNumber, 'Density100C'] = Dens100
        # MoleculeDatabase.at[IDNumber, 'Density40C'] = Dens40
        MoleculeDatabase.at[IDNumber, 'DViscosity40C'] = DVisc40
        MoleculeDatabase.at[IDNumber, 'DViscosity100C'] = DVisc100
        # MoleculeDatabase.at[IDNumber, 'KViscosity40C'] = GAF.GetKVisc(DVisc=DVisc40, Dens=Dens40)
        # MoleculeDatabase.at[IDNumber, 'KViscosity100C'] = GAF.GetKVisc(DVisc=DVisc100, Dens=Dens100)
        # MoleculeDatabase.at[IDNumber, 'KVI'] = KVI
        MoleculeDatabase.at[IDNumber, 'DVI'] = DVI
        MoleculeDatabase.at[IDNumber, 'Toxicity'] = ToxNorm
        MoleculeDatabase.at[IDNumber, 'SCScore'] = SCScoreNorm
        MoleculeDatabase.at[IDNumber, 'ThermalConductivity'] = ThermalK
        MoleculeDatabase.at[IDNumber, 'SimilarityScore'] = SCScoreNorm

    except Exception as E:
        print(E)
        pass

#### Generate Score
ViscScores = MoleculeDatabase['DViscosity40C'].tolist()
SCScores = MoleculeDatabase['SCScore'].tolist()
DVIScores = MoleculeDatabase['DVI'].tolist()
ToxicityScores = MoleculeDatabase['Toxicity'].tolist()
SimilarityScores = MoleculeDatabase['SimilarityScore'].tolist()
ThermalKScores = MoleculeDatabase['ThermalConductivity'].tolist()
MoleculeNames = MoleculeDatabase['ID'].tolist()

ViscosityScore  = list(zip(MoleculeNames, ViscScores)) 
MolecularComplexityScore  = list(zip(MoleculeNames, SCScores)) 
DVIScore  = list(zip(MoleculeNames, DVIScores)) 
ToxicityScore  = list(zip(MoleculeNames, ToxicityScores)) 
ThermalKScore = list(zip(MoleculeNames, ThermalKScores)) 

# Apply the normalization function
Viscosity_normalized_molecule_scores = [(1-x[1]) for x in GAF.min_max_normalize(ViscosityScore)]
DVI_normalized_molecule_scores = [x[1] for x in GAF.min_max_normalize(DVIScore)]
ThermalK_normalized_molecule_scores = [x[1] for x in GAF.min_max_normalize(ThermalKScore)]

MoleculeDatabase['ViscNormalisedScore'] = Viscosity_normalized_molecule_scores
MoleculeDatabase['DVINormalisedScore'] = DVI_normalized_molecule_scores
MoleculeDatabase['ThermalKNormalisedScore'] = ThermalK_normalized_molecule_scores
MoleculeDatabase['TotalScore'] = MoleculeDatabase['Toxicity'] + MoleculeDatabase['SCScore'] + MoleculeDatabase['ThermalKNormalisedScore'] + MoleculeDatabase['DVINormalisedScore'] + MoleculeDatabase['ViscNormalisedScore'] 
MoleculeDatabase['NichedScore'] = MoleculeDatabase['TotalScore'] / MoleculeDatabase['SimilarityScore']

#Make a pandas object with just the scores and the molecule ID
GenerationMolecules = pd.Series(MoleculeDatabase.NichedScore.values, index=MoleculeDatabase.ID).dropna().to_dict()

# Sort dictiornary according to target score
ScoreSortedMolecules = sorted(GenerationMolecules.items(), key=lambda item:item[1], reverse=True)

#Convert tuple elements in sorted list back to lists 
ScoreSortedMolecules = [list(x) for x in ScoreSortedMolecules]

# Constructing entries for use in subsequent generation
for entry in ScoreSortedMolecules:
    Key = int(entry[0].split('_')[-1])
    entry.insert(1, MoleculeDatabase.iloc[Key]['MolObject'])
    entry.insert(2, MoleculeDatabase.iloc[Key]['MutationList'])
    entry.insert(3, MoleculeDatabase.iloc[Key]['HeavyAtoms'])
    entry.insert(4, MoleculeDatabase.iloc[Key]['SMILES'])

#Save the update Master database and generation database
MoleculeDatabase.to_csv(f'{STARTINGDIR}/MoleculeDatabase.csv')
GenerationDatabase.to_csv(f'{STARTINGDIR}/Generation1Database.csv')

################################## Subsequent generations #################################################
for generation in range(2, MaxGenerations + 1):
    GenerationTotalAttempts = 0
    GenSimList = []

    # Generation Dataframe to store molecules from each generation
    GenerationDatabase = pd.DataFrame(columns=['SMILES', 'MolObject', 'MutationList', 'HeavyAtoms', 'ID', 'Charge', 'MolMass', 'Predecessor', 'Score', 'Density100C', 'DViscosity40C',
                                            'DViscosity100C', 'KViscosity40C', 'KViscosity100C', 'KVI', 'DVI', 'ThermalConductivity', 'Toxicity', 'SCScore', 'Density40C', 'SimilarityScore'])

    os.chdir(STARTINGDIR)
    # Store x best performing molecules (x=NumElite in list for next generation, without mutating them)
    GenerationMoleculeList = ScoreSortedMolecules[:NumElite]
    os.chdir(join(os.getcwd(), 'Molecules')) 
    GAF.runcmd(f'mkdir Generation_{generation}')
    os.chdir(STARTINGDIR)

    for i, entry in enumerate(ScoreSortedMolecules): #Start by mutating best performing molecules from previous generation and work down
        MutMol = None
        attempts = 0

        # Stop appending mutated molecules once generation reaches desired size
        if len(GenerationMoleculeList) == GenerationSize:
            break

        # Attempt crossover/mutation on each molecule, not moving on until a valid mutation has been suggested
        while MutMol == None:
            attempts += 1
            GenerationTotalAttempts += 1

            # Limit number of attempts at mutation, if max attempts exceeded, break loop to attempt on next molecule
            if attempts >= MaxMutationAttempts:
                Fails += 1 
                break

            # Get two parents using 3-way tournament selection
            Parent1 = GAF.KTournament(ScoreSortedMolecules[:NumElite])[0]
            Parent2 = GAF.KTournament(ScoreSortedMolecules[:NumElite])[0]

            # Attempt crossover
            try:
                result = GAF.Mol_Crossover(Chem.MolFromSmiles(Parent1), Chem.MolFromSmiles(Parent2))
            except Exception as E:
                pass

            # List containing last two successful mutations performed on molecule
            PreviousMutations = entry[2]
            # Number of heavy atoms
            NumHeavyAtoms = entry[3]
            # Molecule ID
            Name = f'Generation_{generation}_Molecule_{IDcounter}'

            if NumHeavyAtoms > MaxNumHeavyAtoms * 0.8:
                MutationList = ['RemoveAtom', 'ReplaceAtom', 'ReplaceBond', 'RemoveFragment']
            else:
                MutationList = Mutations 
            
            print(f'\n#################################################################\nNumber of attempts: {attempts}')
            print(f'Total Crossover and/or Mutation Attempts: {GenerationTotalAttempts}')
            print(f'GENERATION: {generation}')

            #Decide whether to mutate molecule based on mutation rate
            if random.random() <= MutationRate:
                Mutate = True
                print('Attempting to Mutate')
            else:
                Mutate = False

            if Mutate:
                # Randomly select a mutation, here is where we can set mutation probabilities
                Mutation = rnd(MutationList)

                # Initialise Aromatic Ring
                AromaticMolecule = fragments[-1]

                #Perform mutation, return Mut_Mol, Mut_Mol_Sanitized, MutMolSMILES, StartingMoleculeUnedited
                result = GAF.Mutate(StartingMolecule, Mutation, AromaticMolecule, AtomicNumbers, BondTypes, Atoms, showdiff, fragments)
            
            if GAF.GenMolChecks(result, MasterMoleculeList, MaxNumHeavyAtoms, MinNumHeavyAtoms, MaxAromRings=2) == None:
                MutMol = None
        
            else:
                HeavyAtoms = result[0].GetNumHeavyAtoms() # Get number of heavy atoms in molecule
                MutMol = result[0] # Get Mol object of mutated molecule
                MolMass = GAF.GetMolMass(MutMol) # Get estimate of of molecular mass 
                MutMolSMILES = result[2] # SMILES of mutated molecule

                # Update previous mutations object
                PreviousMutations.pop(0)
                PreviousMutations.append(Mutation)

                print(f'Final SMILES: {result[2]}')

                try: # Try to generate all necessary files to simulate molecule
                    # Set feature definition file path to OPLS or LOPLS depending on user choice 
                    if LOPLS:
                        LTCOMMAND = f"{join(os.getcwd(), 'rdlt.py')} --smi {MutMolSMILES} -n {Name} -l -c"
                    else:
                        LTCOMMAND = f"{join(os.getcwd(), 'rdlt.py')} --smi {MutMolSMILES} -n {Name} -c"
                    
                    # Return to starting directory
                    os.chdir(STARTINGDIR) 
                    
                    #Attempt to parameterise with (L)OPLS
                    GAF.runcmd(f'{PYTHONPATH} {LTCOMMAND} > {STARTINGDIR}/{Name}.lt')

                    #Get molecule charge
                    charge = GAF.GetMolCharge(f'{os.getcwd()}/{Name}.lt')

                    #If successful, generate a PDB of molecule to use with Packmol
                    GAF.GeneratePDB(MutMolSMILES, PATH=join(STARTINGDIR, f'{Name}.pdb'))

                    # Go into directory for this generation
                    os.chdir(join(STARTINGDIR, 'Molecules', f'Generation_{generation}'))
                    
                    # Make a directory for the current molecule if it can be parameterised 
                    GAF.runcmd(f'mkdir {Name}')

                    # Enter molecule specific directory
                    os.chdir(join(os.getcwd(), f'{Name}'))

                    #Check if file has already been made, skip if so, being sure not to make duplicate, otherwise move file to correct directory
                    CWD = os.getcwd()
                    GAF.CheckMoveFile(Name, STARTINGDIR, 'lt', CWD)
                    GAF.CheckMoveFile(Name, STARTINGDIR, 'pdb', CWD)

                    # Make packmol files
                    GAF.MakePackmolFile(Name, CWD, NumMols=NumMols, BoxL=BoxL)

                    # Make Moltemplate files
                    GAF.MakeMoltemplateFile(Name, CWD, NumMols=NumMols, BoxL=BoxL)

                    # Make LAMMPS files
                    GAF.MakeLAMMPSFile(Name, CWD, Temp=313, GKRuntime=1500000)
                    GAF.MakeLAMMPSFile(Name, CWD, Temp=373, GKRuntime=1500000)

                    if PYTHONPATH == 'python3':
                        GAF.runcmd(f'packmol < {Name}.inp') # Run packmol in command line
                        GAF.runcmd(f'moltemplate.sh -pdb {Name}_PackmolFile.pdb {Name}_system.lt') # Run moltemplate in command line

                        # Check that Moltemplate has generated all necessary files 
                        assert os.path.exists(join(CWD, f'{Name}_system.in.settings')), 'Settings file not generated'                 
                        assert os.path.exists(join(CWD, f'{Name}_system.in.charges')), 'Charges file not generated'
                        assert os.path.exists(join(CWD, f'{Name}_system.data')), 'Data file not generated'                    
                        assert os.path.exists(join(CWD, f'{Name}_system.in.init')), 'Init file not generated'                

                    # Return to starting directory
                    os.chdir(STARTINGDIR)

                    # Add candidate and it's data to master list
                    MoleculeDatabase = GAF.DataUpdate(MoleculeDatabase, IDCounter=IDcounter, MutMolSMILES=MutMolSMILES, MutMol=MutMol, HeavyAtoms=HeavyAtoms,
                                            MutationList=PreviousMutations, ID=Name, Charge=charge, MolMass=MolMass, Predecessor=[Parent1, Parent2])
                    
                    # Generate list of molecules to simulate in this generation
                    GenSimList.append([Name, MutMolSMILES])
                    MasterMoleculeList.append(MutMolSMILES) #Keep track of already generated molecules
                    print(f'Final Molecule SMILES: {MutMolSMILES}') 
                    IDcounter += 1

                except Exception as E:
                    print(E)
                    continue   

    #This is where we should call the simulation script
    CWD = join(STARTINGDIR, 'Molecules', f'Generation_{generation}')
    # Create array job for 40C viscosity
    GAF.CreateArrayJob(STARTINGDIR, CWD, generation, NumRuns, SimName=f"313K.lammps", Agent=Agent)
    # Create array job for 100C viscosity
    GAF.CreateArrayJob(STARTINGDIR, CWD, generation, NumRuns, SimName=f"373K.lammps", Agent=Agent)

    if PYTHONPATH == 'python3':
        GAF.runcmd(f'qsub {join(CWD, f"{Agent}_313K.lammps.pbs")}')

    if PYTHONPATH == 'python3':
        GAF.runcmd(f'qsub {join(CWD, f"{Agent}_373K.lammps.pbs")}')

    os.chdir(STARTINGDIR)

    # Wait until array jobs have finished
    MoveOn = False
    while MoveOn == False:
        runcmd(f'qstat > sims.txt')
        sims = []
        with open(join(STARTINGDIR, 'sims.txt'), 'r') as file:
            try:
                next(file)
                next(file)
                filelist = file.readlines()
                for sim in filelist:
                    if Agent in sim:
                        sims.append(sim)
                        print(sim)

                # Check if array jobs have finished
                if len(sims) != 0:
                    print('Waiting for 10 mins')
                    sleep(60)
                else:
                    MoveOn = True
            
            except Exception as E:
                print(E)
                MoveOn = True
                pass
        
    MOLSMILESList = [x[-1] for x in GenSimList]

    # Here is where we will get the various values generated from the MD simulations
    for Molecule, MOLSMILES in GenSimList:
        try:
            os.chdir(join(STARTINGDIR, 'Molecules', f'Generation_{generation}', Molecule))
            CWD = os.getcwd()

            ### Similarity Scores
            Scores = GAF.TanimotoSimilarity(MOLSMILES, MOLSMILESList)
            AvScore = 1 - (sum(Scores) / 50) # The higher the score, the less similar the molecule is to others

            ### SCScore
            SCScore = GAF.SCScore(MOLSMILES)
            SCScoreNorm = SCScore/5

            ### Toxicity
            ToxNorm = random.uniform(0, 1)
            # ToxNorm = GAF.Toxicity(MOLSMILES)

            ### Viscosity
            # DVisc40 = GAF.GetVisc(STARTDIR, Molecule, 313)
            # DVisc100 = GAF.GetVisc(STARTDIR, Molecule, 373)
            # Dens40 = GAF.GetDens(DensityFile)
            # Dens100 = GAF.GetDens(DensityFile
            DVisc40 = random.uniform(2, 30)
            DVisc100 = random.uniform(2, 8)

            ### Viscosity Index
            # Dens40 = GAF.GetDens(DensityFile)
            # Dens100 = GAF.GetDens(DensityFile)
            # KVI = GAF.GetKVI(DVisc40, DVisc100, Dens40, Dens100, STARTINGDIR)
            DVI = GAF.GetDVI(DVisc40, DVisc100)

            ### Thermal Conductivity
            ThermalK = random.uniform(1, 3)

            #Update Molecule Database
            IDNumber = int(Molecule.split('_')[-1])
            # MoleculeDatabase.at[IDNumber, 'Density100C'] = Dens100
            # MoleculeDatabase.at[IDNumber, 'Density40C'] = Dens40
            MoleculeDatabase.at[IDNumber, 'DViscosity40C'] = DVisc40
            MoleculeDatabase.at[IDNumber, 'DViscosity100C'] = DVisc100
            # MoleculeDatabase.at[IDNumber, 'KViscosity40C'] = GAF.GetKVisc(DVisc=DVisc40, Dens=Dens40)
            # MoleculeDatabase.at[IDNumber, 'KViscosity100C'] = GAF.GetKVisc(DVisc=DVisc100, Dens=Dens100)
            # MoleculeDatabase.at[IDNumber, 'KVI'] = KVI
            MoleculeDatabase.at[IDNumber, 'DVI'] = DVI
            MoleculeDatabase.at[IDNumber, 'Toxicity'] = ToxNorm
            MoleculeDatabase.at[IDNumber, 'SCScore'] = SCScoreNorm
            MoleculeDatabase.at[IDNumber, 'ThermalConductivity'] = ThermalK
            MoleculeDatabase.at[IDNumber, 'SimilarityScore'] = SCScoreNorm

        except Exception as E:
            print(E)
            pass

    #### Generate Score
    ViscScores = MoleculeDatabase['DViscosity40C'].tolist()
    SCScores = MoleculeDatabase['SCScore'].tolist()
    DVIScores = MoleculeDatabase['DVI'].tolist()
    ToxicityScores = MoleculeDatabase['Toxicity'].tolist()
    SimilarityScores = MoleculeDatabase['SimilarityScore'].tolist()
    ThermalKScores = MoleculeDatabase['ThermalConductivity'].tolist()
    MoleculeNames = MoleculeDatabase['ID'].tolist()

    ViscosityScore  = list(zip(MoleculeNames, ViscScores)) 
    MolecularComplexityScore  = list(zip(MoleculeNames, SCScores)) 
    DVIScore  = list(zip(MoleculeNames, DVIScores)) 
    ToxicityScore  = list(zip(MoleculeNames, ToxicityScores)) 
    ThermalKScore = list(zip(MoleculeNames, ThermalKScores)) 

    # Apply the normalization function
    Viscosity_normalized_molecule_scores = [(1-x[1]) for x in GAF.min_max_normalize(ViscosityScore)]
    DVI_normalized_molecule_scores = [x[1] for x in GAF.min_max_normalize(DVIScore)]
    ThermalK_normalized_molecule_scores = [x[1] for x in GAF.min_max_normalize(ThermalKScore)]

    MoleculeDatabase['ViscNormalisedScore'] = Viscosity_normalized_molecule_scores
    MoleculeDatabase['DVINormalisedScore'] = DVI_normalized_molecule_scores
    MoleculeDatabase['ThermalKNormalisedScore'] = ThermalK_normalized_molecule_scores
    MoleculeDatabase['TotalScore'] = MoleculeDatabase['Toxicity'] + MoleculeDatabase['SCScore'] + MoleculeDatabase['ThermalKNormalisedScore'] + MoleculeDatabase['DVINormalisedScore'] + MoleculeDatabase['ViscNormalisedScore'] 
    MoleculeDatabase['NichedScore'] = MoleculeDatabase['TotalScore'] / MoleculeDatabase['SimilarityScore']

    #Make a pandas object with just the scores and the molecule ID
    GenerationMolecules = pd.Series(MoleculeDatabase.NichedScore.values, index=MoleculeDatabase.ID).dropna().to_dict()

    # Sort dictiornary according to target score
    ScoreSortedMolecules = sorted(GenerationMolecules.items(), key=lambda item:item[1], reverse=True)

    #Convert tuple elements in sorted list back to lists 
    ScoreSortedMolecules = [list(x) for x in ScoreSortedMolecules]

    # Constructing entries for use in subsequent generation
    for entry in ScoreSortedMolecules:
        Key = int(entry[0].split('_')[-1])
        entry.insert(1, MoleculeDatabase.iloc[Key]['MolObject'])
        entry.insert(2, MoleculeDatabase.iloc[Key]['MutationList'])
        entry.insert(3, MoleculeDatabase.iloc[Key]['HeavyAtoms'])
        entry.insert(4, MoleculeDatabase.iloc[Key]['SMILES'])

    
    MoleculeDatabase.to_csv(f'{STARTINGDIR}/MoleculeDatabase.csv')
    GenerationDatabase.to_csv(f'{STARTINGDIR}/Generation{generation}_Database.csv')

print(len(GenerationMoleculeList))
print(f'Number of failed mutations: {Fails}')
print(len(ScoreSortedMolecules[:NumElite]))
