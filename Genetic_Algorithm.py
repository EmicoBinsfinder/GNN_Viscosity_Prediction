"""
Author: Egheosa Ogbomo
Date: 11/10/2023

An implementation of a genetic algoritm that:

- Allows user to generate varying lengths of molecules for optimisation
- Define their own fitness function (an ML algorithm or MD simulation framework)
- Remove molecules with undesired substructures from populations
- Define likelihood of different mutations/crossovers occuring
- Store SMILES strings and evaluations of valid(?) molecules from each generation in csv
- Allow users to define which elements and mutations are allowed from a database (which can be in csv form)
- Remove disconnected fragments
- Check for molecular similarity
- Illustrate mutated molecules between generations
- Plot an illustration of generated molecules as a word embedding
- Find most common substructure present within a generation of champion molecules to advise future generations
- Limit number of atoms generated by algorithm
- Generate options that conform to a specific type of base oils (e.g. PAO/silicone oils)

CONSTRAINTS

- Allow only one mutation per generation

CONSIDERATIONS

- Think about using Python pickle structure to save molecules for speeding up molecule loading

- Best way to initialise population

- How to penalise long surviving molecules to encourage even greater diversity in later generations

- Need to determine how to handle crossovers

- How to know if something is a gas or liquid

- Are we only going to add to end points
    - Maybe a coinflip or some form of distribution to determine where alteration is made

- Decide a protocol for adding branches top 

- How to implement a validity check before evaluating the fitness of molecules in a generation and which validity checks to implement
    - Can the molecule be parameterised?

- How to ensure that we are actually generating molecules that will be liquid at room temperature (how do we design gaseous lubricants)

- Need to decide best fingerprint for calculating molecular similarity

"""

################# IMPORTS ###################

from rdkit import Chem
from rdkit.Chem import Draw
import rdkit
import random
from rdkit.Chem import AllChem
from rdkit.Chem.Draw import MolDrawing, DrawingOptions
DrawingOptions.includeAtomNumbers=True
DrawingOptions.bondLineWidth=1.8
DrawingOptions.atomLabelFontSize=14


############## Defining different molecule types ###################
naphthalene = Chem.MolFromSmiles('c12ccccc1cccc2')
benzoxazole = Chem.MolFromSmiles('n1c2ccccc2oc1')
indane = Chem.MolFromSmiles('c1ccc2c(c1)CCC2')
skatole = Chem.MolFromSmiles('CC1=CNC2=CC=CC=C12')
benzene = Chem.MolFromSmiles('c1ccccc1')
quinoline = Chem.MolFromSmiles('n1cccc2ccccc12')

my_molecules = [naphthalene, benzoxazole, indane, skatole, benzene, quinoline]

#### Test genetic algorithm starting from benzene

"""
Need to decide if centers are secondary, tertiary or quarternary
"""

### Fragments
fragments = ['c1ccccc1', 'CCC', 'CC(C)CCCCCCCOC(=O)CCCCC(=O)OCCCCCCCC(C)C', 'CC', 'CCCC', 'CCCCC', 'CCCCCCC']
fragments = [Chem.MolFromSmiles(x) for x in fragments]

### Atom Numbers
Atoms = ['C', 'O']
AtomMolObjects = [Chem.MolFromSmiles(x) for x in Atoms]
AtomicNumbers = []

## Getting Atomic Numbers for Additive Atoms
for Object in AtomMolObjects:
     for atom in Object.GetAtoms():
          AtomicNumbers.append(atom.GetAtomicNum())         

# Bond Types
BondTypes = [Chem.BondType.SINGLE, Chem.BondType.DOUBLE, Chem.BondType.TRIPLE]

starting_molecule = Chem.MolFromSmiles('CCC')
combo = Chem.CombineMols(fragments[2], starting_molecule)

#Finds disconnected molecules in a SMILES string
frags = Chem.GetMolFrags(combo)

#Steps

"""
1. Combine molecules into a singular SMILES object 
2. Create separate objects for each fragment in SMILES string 
3. Check bond types for each bond for each atom in each fragment, maybe create separate list containing atoms with each bond type
4. Check whether bonds are aromatic, will need to Kekulize SMILES strings to enable this
5. Check number of rings in the structure
5. Assign probablilities to each potential mutation
6. Select a mutation based on probabilities, taking into account information from starting structure


Possible Mutations
- Add Atom
- Delete Atom (RWMOL.removeAtom)
- Replace Atom
- Change Bond Order
- Delete Ring
- Add Ring
- Add Fragment 
- Delete Fragment

Steps for each Mutation
"""

Starting_molecule = Chem.MolFromSmiles('CCCCCC')

# Change to an editable object
Starting_molecule = Chem.RWMol(Starting_molecule)

# Add selected atom from list of addable atoms 
x = Starting_molecule.AddAtom(Chem.Atom(8))

# Storing indexes of newly added atom and atoms from intial molecule

frags = Chem.GetMolFrags(Starting_molecule)

# Check which object is the newly added atom
# Don't assume new atom index is always added to end of GetMolFrags object

for ind, frag in enumerate(frags):
    print(ind, frag)
    if len(frag) == 1:
        #Store index of Atom in Object
        NewAtomIdx = frags[ind]
    else:
        StartMolIdxs = frags[ind]


"""
There are 3 possible outcomes from adding a molecule:

- Branching with single Bond
- Branch with double bond
- Extension

"""

#
Starting_molecule.AddBond(3, NewAtomIdx[0], random.choice(BondTypes))
#Starting_molecule.AddBond(6, 7, BondTypes[1])


# Adding bonds to new atom
"""
How to know if we are adding bonds in the right place?
We'd need to check if there is an aromatic ring
I'd assume that we'd be able to get away with selecting two random adjacent atom ids 
and just adding that way if they are not part of a ring or a branch intersection
"""

# Convert back to editable molecule for illustration
Mut_Mol = Starting_molecule.GetMol()

#Check if chemical rules are violated
# I should store the violation in the object, along with the generated SMILES string, may be useful later on 
Mut_Mol_Sanitzed = Chem.SanitizeMol(Mut_Mol, catchErrors=True) 

img = Draw.MolToImage(Mut_Mol_Sanitzed)
img.show()

def AddAtom(StartingMolecule, NewAtoms=Atoms, Probabilities=[1, 1, 1]):
    """
    Function that Adds Atom atom from 

    Need to ensure that probability of this is zero if length of molecule is too short.

    Takes molecule, adds atom based on defined probabilities of position
     
    """


# for atom in combo.GetAtoms():
#      if atom.IsInRing(): #Should check if molecule is in ring (aromatic or not)
#           print(atom.GetIdx())

#      for bond in atom.GetBonds():
#           print(f'Atom index is {atom.GetIdx()}')
#           print(atom.GetAtomicNum())
#           print(bond.GetBondType())

# for atom in combo.GetAtoms():
#     # For each atom, set the property "atomNote" to a index+1 of the atom
#     atom.SetProp("atomNote", str(atom.GetIdx()+1))

# edcombo = Chem.EditableMol(combo)
# edcombo.AddBond(1, 20,order=Chem.rdchem.BondType.SINGLE)

# edcombo = edcombo.GetMol()

# Smiles = Chem.MolToSmiles(edcombo)
# print(Smiles)

# # Numbering atoms in a RdKit 
# for atom in edcombo.GetAtoms():
#     # For each atom, set the property "atomNote" to a index+1 of the atom (because zero-indexed)
#     atom.SetProp("atomNote", str(atom.GetIdx()+1))

# img = Draw.MolToImage(edcombo)
# img.show()









############ Code to Highlight certain Bonds

# Could be useful to show generational changes as CReM does
"""
from rdkit.Chem.Draw import rdMolDraw2D
smi = 'c1cc(F)ccc1Cl'
mol = Chem.MolFromSmiles(smi)
patt = Chem.MolFromSmarts('ClccccF')
hit_ats = list(mol.GetSubstructMatch(patt))
hit_bonds = []
for bond in patt.GetBonds():
   aid1 = hit_ats[bond.GetBeginAtomIdx()]
   aid2 = hit_ats[bond.GetEndAtomIdx()]
   hit_bonds.append(mol.GetBondBetweenAtoms(aid1,aid2).GetIdx())
d = rdMolDraw2D.MolDraw2DSVG(500, 500) # or MolDraw2DCairo to get PNGs
rdMolDraw2D.PrepareAndDrawMolecule(d, mol, highlightAtoms=hit_ats,
                                   highlightBonds=hit_bonds)
"""

"""
Code for substructure searching 
m = Chem.MolFromSmiles('c1ccccc1O')
patt = Chem.MolFromSmarts('ccO')
m.HasSubstructMatch(patt)
True
m.GetSubstructMatch(patt)
(0, 5, 6)
"""

############ Removing Substructure code

# m = Chem.MolFromSmiles('CC(=O)O')
# patt = Chem.MolFromSmarts('C(=O)O')
# rm = AllChem.DeleteSubstructs(m,patt)
# rmSMILES = Chem.MolToSmiles(rm)

# img_before = Draw.MolToImage(m)
# img_before.show()

# img_after = Draw.MolToImage(rm)
# img_after.show()

################## Replacing Substructures

# Defining the pattern to be replaced 
# To implement as part of GA could just take subsections of SMILES strings per mutation

# repl = Chem.MolFromSmiles('OC')

# patt = Chem.MolFromSmarts('[$(NC(=O))]')
# m = Chem.MolFromSmiles('CC(=O)N')
# img_before = Draw.MolToImage(m)
# img_before.show()

# # Define molecule, the substructure to be replaced, and what is should be replaced with, in that order
# rms = AllChem.ReplaceSubstructs(m,patt,repl)

# Chem.MolToSmiles(rms[0])
# img_after = Draw.MolToImage(rms[0])
# img_after.show()


###### Code to remove side excess molecules from core molecule

# m1 = Chem.MolFromSmiles('BrCCc1cncnc1C(=O)O')
# img_before = Draw.MolToImage(m1)
# img_before.show()

#core = Chem.MolFromSmiles('c1cncnc1')
# tmp = Chem.ReplaceSidechains(m1,core)
# img_after = Draw.MolToImage(tmp)
# img_after.show()
#Chem.MolToSmiles(tmp)

####### Code to remove core molecule and be left with fragments

#tmp = Chem.ReplaceCore(m1,core)
# Chem.MolToSmiles(tmp)
# img_after = Draw.MolToImage(tmp)
# img_after.show()

# Code to get molecular fragments
"""
Really useful for determining longest continuous fragment and getting rid of nonsense, such as with VAE generated molecules
"""
#rs = Chem.GetMolFrags(tmp,asMols=True)

####### Code to generate 2D SMILES coordiate that has been conformed to minimise intramolecular clashes 

# m = Chem.MolFromSmiles('c1nccc2n1ccc2')
# AllChem.Compute2DCoords(m)

##### Minimise Molecules in RDKIT using MMFF94 forcefield 

# m = Chem.MolFromSmiles('C1CCC1OC')
# # Need to make sure you make hydrogens explicit before optimising molecules
# m2=Chem.AddHs(m)
# AllChem.EmbedMolecule(m2)
# AllChem.MMFFOptimizeMolecule(m2)

###### Code to consider chirality of molecule when assessing substructure matches

#m.HasSubstructMatch(Chem.MolFromSmiles('C[C@@H](F)Cl'),useChirality=True)

############# Calculate Tanimoto similarity score between two molecules based on fingerprints

## Need to ensure we consider fingerprint hyperparameters when generating fingerprints (max path size, fingerprint size, bits set per hash)

# from rdkit import DataStructs
# ms = [Chem.MolFromSmiles('CCOC'), Chem.MolFromSmiles('CCO'),
# Chem.MolFromSmiles('COC')]
# fpgen = AllChem.GetRDKitFPGenerator()
# fps = [fpgen.GetFingerprint(x) for x in ms]
# DataStructs.TanimotoSimilarity(fps[0],fps[1])

### Code to check if bond is aromatic or not 

def isRingAromatic(mol, bondRing):
        for id in bondRing:
            if not mol.GetBondWithIdx(id).GetIsAromatic():
                return False
        return True

### Code to get info on aromatic bonds in a SMILES string
#ri = m.GetRingInfo()
